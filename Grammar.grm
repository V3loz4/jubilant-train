<CompilationUnit> ::= <DefinitionModule> | IMPLEMENTATION <ProgramModule> | <ProgramModule>

<DefinitionModule> ::= DEFINITION MODULE <Identifier> ";" <R_Import> <R_Definition> END "." |
            DEFINITION MODULE <Identifier> ";" <R_Import> Export <R_Definition> END "."

<R_Import> ::= <R_Import> <Import> |

<R_Definition> ::= <R_Definition> <Definition> |

<Definition> ::= CONST { ConstantDeclaration ";" } |
             TYPE { Identifier [ "=" Type ] ";" } |
             VAR { VariableDeclaration ";" } |
             ProcedureHeading ";"

<ProgramModule> ::= MODULE Identifier [ Priority ] ";" { Import } Block Identifier "."

<Priority> ::= "[" ConstantExpression "]"

<Import> ::= [ FROM Identifier ] IMPORT IdentifierList ";"

<Export> ::= EXPORT [ QUALIFIED ] IdentifierList ";"

<Block> ::= { Declaration } [ BEGIN StatementSequence ] END

<Declaration> ::= CONST { ConstantDeclaration ";" } |
               TYPE { TypeDeclaration ";" } |
               VAR { VariableDeclaration ";" } |
               ProcedureDeclaration ";" |
               ModuleDeclaration ";"

<ConstantDeclaration> ::= Identifier "=" ConstantExpression

<TypeDeclaration> ::= Identifier "=" Type

<Type> ::= SimpleType | ArrayType | SetType | PointerType | ProcedureType

<SimpleType> ::= Qualident | Enumeration | SubrangeType

<Enumeration> ::= "(" IdentifierList ")"

<SubrangeType> ::= "[" ConstantExpression ".." ConstantExpression "]"

<ArrayType> ::= ARRAY SimpleType { "," SimpleType } OF Type

<FieldListSequence> ::= FieldList { ";" FieldList }

<FieldList> ::= [ IdentifierList ":" Type | CASE [ Identifier ":" ] Qualident OF Variant { "|" Variant } [ ELSE FieldListSequence ] ]

<Variant> ::= CaseLabelList ":" FieldListSequence

<CaseLabelList> ::= <CaseLabels> <Aux_CaseLabelList>

<Aux_CaseLabelList> ::= <Aux_CaseLabelList> "," <CaseLabels> |

<CaseLabels> ::= <ConstantExpression> [".." <ConstantExpression> ]

<SetType> ::= SET OF <SimpleType>

<PointerType> ::= POINTER TO <Type>

<ProcedureType> ::= PROCEDURE <FormalTypeList>

<FormalTypeList> ::= "(" [ [ VAR ] <FormalType> <Aux_FormalTypeList> ] ")" [ ":" <Qualident> ]

<Aux_FormalTypeList> ::= <Aux_FormalTypeList> "," [ VAR ] <FormalType> |

<VariableDeclaration> ::= <IdentifierList> ":" <Type>

<ProcedureDeclaration> ::= <ProcedureHeading> ";" <Block> <Identifier>

<ProcedureHeading> ::= PROCEDURE <Identifier> [ <FormalParameters> ]

<FormalParameters> ::= "(" [ <FormalParametersSection> <Aux_FormalParameters> ] ")" [ ":" <Qualident> ]

<Aux_FormalParameters> ::= <Aux_FormalParameters> "," <FormalParametersSection> |

<FormalParametersSection> ::= [ VAR ] <IdentifierList> ":" <FormalType>

<FormalType> ::= [ ARRAY OF ] <Qualident>

<ModuleDeclaration> ::= MODULE <Identifier> [ <Priority> ] ";" <R_Import> [ <Export> ] <Block> <Identifier>

<StatementSequence> ::= <Statement> { ";" <Statement> }

<Statement> ::= [ <Assignment> |
            <ProcedureCall> |
            <IfStatement> |
            <CaseStatement> |
            <WhileStatement> |
            <RepeatStatement> |
            <ForStatement> |
            <WithStatement> |
            EXIT |
            RETURN [ <Expression> ] ]

<Assignment> ::= <Designator> ":=" <Expression>

<ProcedureCall> ::= <Designator> [ <ActualParameters> ]

<IfStatement> ::= IF <Expression> THEN <StatementSequence> { ELSIF <Expression> THEN <StatementSequence> } [ ELSE <StatementSequence> ] END

<CaseStatement> ::= CASE <Expression> OF <Case> <Aux_CaseStatement> [ ELSE <StatementSequence> ] END

<Aux_CaseStatement> ::= <Aux_CaseStatement> "|" <Case> |

<Case> ::= <CaseLabelList> ":" <StatementSequence>

<WhileStatement> ::= WHILE <Expression> DO <StatementSequence> END

<RepeatStatement> ::= REPEAT <StatementSequence> UNTIL <Expression>

<ForStatement> ::= FOR <Identifier> ":=" <Expression> TO <Expression> [ BY <ConstantExpression> ] DO <StatementSequence> END

<WithStatement> ::= WITH <Designator> DO <StatementSequence> END

<ActualParameters> ::= "(" [ <ExpressionList> ] ")"

<ExpressionList> ::= <Expression> <Aux_ExpressionList>

<Aux_ExpressionList> ::= <Aux_ExpressionList> "," <Expression> |

<Expression> ::= <SimpleExpression> [ <RelOperator> <SimpleExpression> ]

<SimpleExpression> ::= [ "+" | "-" ] <Term> <Aux_SimpleExpresions>

<Aux_SimpleExpresions> ::= <Aux_SimpleExpresions> <AddOperator <Term> |

<Term> ::= <Factor> <Aux_Term>

<Aux_Term> ::= <Aux_Term> <MulOperator> <Factor> |

<Factor> ::= <Number> | <String> | <Set> | <Designator> [ <ActualParameters> ] | "(" <Expression> ")" | NOT <Factor>

<ConstantExpression> ::= <SimpleConstantExpression> [ <RelOperator> <SimpleConstantExpression> ]

<SimpleConstantExpression> ::= [ "+" | "-" ] <ConstantTerm> <Aux_SimpleConstantExpression>

<Aux_SimpleConstantExpression> ::= <Aux_SimpleConstantExpression> <AddOperator> <ConstantTerm> |

<ConstantTerm> ::= <ConstantFactor> <Aux_Constant_Term>

<Aux_ConstantTerm> ::= <Aux_ConstantTerm> <MulOperator> <ConstantFactor> |

<ConstantFactor> ::= <Qualident> | <Number> | <String> | <Set> | "(" <ConstantExpression> ")" | NOT <ConstantFactor>

<Set> ::= [ <Qualident> ] "{" [ <Element> { "," <Element> } ] "}"

<Element> ::= <ConstantExpression> [ ".." <ConstantExpression> ]

<Designator> ::= <Qualident> <Aux_Designator>

<Aux_Designator> ::= <Aux_Designator> "." Identifier | <Aux_Designator> "[" ExpressionList "]" | <Aux_Designator> "^" |

<Qualident> ::= Identifier <Aux_Qualident>

<Aux_Qualident> ::= <Aux_Qualident> "." <Identifier> |

<IdentifierList> ::= <Identifier> <Aux_IdentifierList>

<Aux_IdentifierList> ::= <Aux_IdentifierList> "," <Identifier> |

<RelOperator> ::= "=" | "#" | "<>" | "<" | "<=" | ">" | ">=" | <IN>

<AddOperator> ::= "+" | "-" | <OR>

<MulOperator> ::= "*" | "/" | <DIV> | <MOD> | <AND> | "&"
!TODO: Add all letters...
<Letter> ::= "a" | ... | "z" | "A" | ... | "Z"

<Identifier> ::= <Letter> <Aux_Identifier>

<Aux_Identifier> ::= <Aux_Identifier> <Letter> | <Aux_Identifier> <Digit> |

<Number> ::= <Integer> | <Real>

<Integer> ::= Digit { Digit } | OctalDigit { OctalDigit } ( "B" | "C" ) | Digit { HexDigit } "H"

<Real> ::= Digit { Digit } "." { Digit }[ "E" [ "+" | "-" ] Digit { Digit }

<HexDigit> ::= Digit | "A" | "B" | "C" | "D" | "E" | "F"

<Digit> ::= OctalDigit | "8" | "9"

<OctalDigit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"

<String> ::= """ { Character } """

<Character> ::= ";"
